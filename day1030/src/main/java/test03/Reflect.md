# 一、反射
1、为什么要有反射？
Java一开始设计时，是静态语言。
静态语言==》所有的变量等的类型，必须是在编译时要确定类型的。

但是实际开发中，编译时，确实不能确定某个变量的具体的类型，
最多能确定它属于某个系列（父类的子类）或者说它遵循了什么标准（什么接口的实现类）；
在运行期间才能确定它的具体类型。

但是问题来了，如果没有反射，我们如果不确定具体的子类或实现类的话，是无法new对象的。
这个时候，我们就需要动态的在运行时确定类型，但是我们new对象的代码要提前在编译期间编写。

原来：确定类型-->对象
现在：对象-->类型的信息

总结：有了反射，使得JAVA具体动态语言的特征。

像Javascript等语言就是动态语言。

2、反射应用在：web服务器、框架等代码的编写中
# 二、类加载
1、无论是静态语言还是动态语言特征，创建对象之前，都需要先将类加载到内存（方法区），然后才能new对象。

2、类加载的过程
（1）什么情况下会发生类的加载？
当我们手动使用类加载器的相应方法去主动加载某个类 或 我们在第一次使用某个类时，类加载器会自动帮我们加载这个类。
（2）具体的过程
A：load加载：IO操作，
可以从本地的.class文件读取某个类的字节码信息，
也可以从网络中接收.class字节码信息，
也可以从数据库服务器中某个表中读取字节码信息
....

B：link连接
①验证：
a：字节码格式的规范
有很多，其中一条，所有的字节码文件的开头必须是cafebabe
b：版本是否正确
如果当前运行环境是Java8的，而你的字节码是Java7，这个可以支持，因为可以向下兼容
如果当前运行环境是Java7的，而你的字节码是Java8，这个是不支持的
c：....
②准备：
a：在方法区给这个类的信息存储分配一块内存。每一个类加载之后，都会在方法区有一块独立的内存。
会用一个Class对象来表示一个类。该类的信息全部存储在Class对象中。
不同的类型，就有不同的Class对象。
b：并且要给这个类的静态变量在方法区中开辟内存，并且暂时先赋默认值
c：如果有常量声明，在方法区也会给常量分配内存，并且把常量进行初始化
③解析：
把.class中的符号引用替换为对应的直接地址引用
例如：  .class中出现了 String，它是符号引用，它代表String类型。
String类型也是一个类型，它在方法区应该也会有一块内存存String类型的信息。
解析的过程，就是把String 这个符号  直接替换为，它在方法区的地址。

           下次运行时，就不用现找String的位置在哪里，它有什么方法，有什么指令。直接去该位置找。

           .class中出现了Math.PI，它也是符号引用，它是一个常量。
           Math.PI是一个常量，在方法区也会有一个内存来存它的值。
           解析的过程，就是把Math.PI，这个符号，直接替换为它在方法区的地址。

C：类初始化
本质上就是运行该类的<clinit>()方法，为静态变量初始化。

3、类的加载的特殊情况：
正常情况：类的加载的load,link,clinit是一口气完成的。
特殊情况：类的加载的load,link先完成，然后clinit滞后了，延迟了。

下面要说明哪些情况是一口气完成的，哪些情况是分开完成的。这个在面试题中会出现。
（1）一口气完成的
A：main所在的类，它的load,link,clinit是一口气完成的。
因为必须先完成类初始化，才能执行main方法。
B：第一次使用某个类型就是在new它的对象，必须先完成类初始化，才能new对象
C：调用某个类的静态成员（类变量和类方法）
D：子类初始化时，发现它的父类还没有初始化的话，那么先初始化父类
即父类初始化一定先与子类
E：通过反射操作某个类时，如果这个类没有初始化

4、类加载器
（1）类的加载是由类加载器来完成的。
类加载器是ClassLoader类型的对象。

（2）它可以分为4大类
A：根加载器/引导类加载器：（Bootstrap Classloader）
作用：负责加载jre/rt.jar核心库，Java程序的基石。
注意：引导类加载器不是Java语言写的，是C 写的，所以得不到它的对象，得到是null
B：扩展类加载器（Extension ClassLoader）
作用：负责加载jre/lib/ext扩展库
例如：D:\ProgramFiles\Java\jdk1.8.0_141\jre\lib\ext
C：应用程序类加载器（Application Classloader）
作用：负责项目的classpath路径下的类，即我们程序员自己写的类
D：自定义类加载器
作用：加载上面ABC以外的路径下的类，或者说 某个类的.class需要加密和解密时需要自定义类加载器。

（3）如何确定某个类是哪个类加载器加载的
步骤：
第一步：先得到这个类的Class对象
第二步：通过Class对象.getClassLoader()就可以获取加载这个类的类加载器对象

（4）为什么要设计这么多种类加载器？或者问，为什么不同路径下的类要使用不同的类加载器，
以及它们是如何协作工作的？
ABC三种类加载器是有一个工作模式：双亲委托模式
双亲：父母双亲
C是B看成它的父加载器  ，通过c加载器对象.getParent()，可以得到B加载器对象
B把A看成它的父加载器  ，通过B加载器对象.getParent()，可以得到A加载器对象 (null)

注意：这里的双亲不是通过继承方式体现的，而是通过组合的方式。

继承：
class A{
}
class B extends A{
}

组合：
class A{
}
class B{
private A parent;
public A getParent(){
return parent;
}
}

为什么要这么设计？==> 安全
如何工作？
第一步：当C（应用程序类加载器）接收到一个加载任务时，首先会看一下这个类它是否加载过了；
如果这个类已经加载过了，那么直接返回这个类Class对象，不会重复加载。
如果这个类没有加载过，那么它会把这个任务先提交给 它父加载器B“扩展类加载器”
第二步：当B（扩展类加载器）接收到加载任务时，也会看一下这个类它是否加载过了；
如果这个类已经加载过了，那么直接返回这个类Class对象，不会重复加载。
如果这个类没有加载过，那么它会把这个任务先提交给 它父加载器A“引导类加载器”
第三步：当A(引导类加载器)接收到加载任务时，也会看一下这个类它是否加载过了；
如果这个类已经加载过了，那么直接返回这个类Class对象，不会重复加载。
如果这个类没有加载过，那么它会在它负责的 rt.jar中搜索这个类，如果可以找到，就加载它；
如果不能找到，会把任务往回传，传给B；
第四步：当B（扩展类加载器）从A哪里接收到往回传的任务时，
B会在它负责的目录（jre/lib/ext)下搜索，如果可以找到，就加载它；
如果不能找到，会把任务往回传，传给C；
第五步：当C（应用程序类加载器）从B哪里接收到往回传的任务时，
C会在它负责的目录（项目的类路径下，例如：idea的out目录)下搜索，如果可以找到，就加载它；
如果不能找到，就报错ClassNotFoundException。

如果找到class文件，但是加载失败（不合格的等），也会报（java.lang.NoClassDefError）等错误。

例如：我们现在有一个类需要加载，类的名字是java.lang.String。
如果假设我让应用程序类加载器(c)去加载java.lang.String，并且它也给我们加载了，
那么就会导致内存中，有一个我们自己写的java.lang.String和系统定义的java.lang.String同时存在，
无法区分，或者说，我们的这个会覆盖它的功能，这样的话就会有安全问题。

现在发现，我们虽然是让应用程序类加载器(c)去加载java.lang.String，但是它没有自己加载，
而是任务往上提交了，最终到达跟加载器，它只会在rt.jar中找java.lang.String，
它加载的一定是系统的String。不会因为我们自己（不小心，故意）写了和系统的某个类包和类重名的
问题，而导致系统无法正常运行。

（2）类的加载的load,link先完成，然后clinit滞后了，延迟了
A：使用某个类的静态的常量（static  final）
B：用某个类型声明数组并创建数组对象时
C：通过子类调用父类的静态变量，静态方法，只会导致父类初始化，
不会导致子类初始化，即只有声明静态成员的类才会初始化

三、java.lang.Class类
1、类加载的结果，就是在方法区生成了某个类对应的一个Class对象。
如果能够在方法区找到某个类的Class对象，就说明这个类已经成功加载了。

2、问题：
（1）如何在程序中，获取  Class对象？
（2）获取到Class对象之后能干什么？

3、哪些类型有Class？
Class 类的实例表示正在运行的 Java 应用程序中的类和接口。 ==> 类和接口都有对应Class对象
枚举是一种类，注解是一种接口。 ==> 把枚举看成是一种特殊的类，注解看成是接口
枚举的声明关键字 enum->class，
注解的声明关键字@interface->interface
每个数组属于被映射为 Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。 ==> 每一种数组也是一个独立的类型
例如：int[] 是一种数据类型
String[]是另一种数据类型
int[][] 又是一种数据类型
int[]和  int[][]不同，它俩维度不同
int[] 和String[]不同，它俩元素类型不同

                                     int[] arr1 = new int[5];
                                     int[] arr2 = new int[10];
                                     arr1和arr2是同一种数据类型，因为他们都是int[]类型，元素的数据类型和维度是一样，他们共享同一个Class对象
基本的 Java 类型（boolean、byte、char、short、int、long、float 和 double）和关键字 void 也表示为 Class 对象 ==> 基本数据类型和void，也有自己的Class对象

4、如何在程序中，获取  Class对象（非常重要）
（1）方式一：类名.class
（2）方式二：对象.getClass()，获取某个对象的运行时类型
这种方式不适用于基本数据类型，因为没有对象
（3）方式三：Class.forName("类型的全名称")
这种方式，更多的用于编译期间未知的类型
（4）方式四：类加载器对象.loadClass("类型的全名称")

四种如何选择？你看当前的情况下，能够用哪种就用哪种，如果多种都能用，选最简单。

问题：方式四：类加载器对象.loadClass("类型的全名称")
ClassLoader不能直接new的，只能获取。
要么通过某个类的Class.getClassLoader()获取到，
要么通过ClassLoader的静态方法getSystemClassLoader()的系统类加载器对象。

具体通过Class对象能干什么？
（1）可以创建任意类型的对象，除了抽象类等不能创建对象的类型以外。
（2）可以操作任意对象的任意成员变量
步骤：
A：获取该类型的Class对象
B：获取你要操作的成员变量的Field对象
C：如果你要获取该成员变量的值，那么调用   Field对象.get(实例对象)
如果你要修改该成员变量的值，那么调用   Field对象.set(实例对象，值)

注意：如果该成员变量有final修饰的话，可以获取值，但不能修改。
如果该成员变量是私有的，那么需要调用  Field对象.setAccessible(true)

获取到Class对象之后能干什么？
反射的根源，基础，必须有Class对象。
为什么？
因为无论你编译期间是否存在某个类型，但是要真正实现功能，运行期间这个类型是必须存在的。
即能够得到某个类的Class对象才可以。

具体通过Class对象能干什么？
（1）可以创建任意类型的对象，除了抽象类等不能创建对象的类型以外。
方式一：
步骤：
A：先获取某个类的Class对象
B：调用Class对象.newInstance()创建类型的实例对象
注意：这个类型必须有公共的无参构造

另一种方式：
步骤：
A：先获取某个类的Class对象
B：获取这个类的构造器对象
Class对象.getConstructors()
Class对象.getDeclaredConstructors()
Class对象.getDeclaredConstructor(构造器形参的类型的Class对象)
Class对象.getConstructor(构造器形参的类型的Class对象)
C：通过构造器对象.newInstance(..)创建对象

注意：如果构造器的权限修饰符限制我们了，我们可以调用
构造器对象.setAccessible(true)

除非这个类是抽象类等不能创建对象。