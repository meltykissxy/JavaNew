package com.atguigu.test01;

//import static java.lang.Math.PI;
import static java.lang.Math.*;
import static com.atguigu.test01.Week.*;

/*
一、static关键字
1、static：静态的
2、是一个修饰符，可以修饰
（1）方法
（2）成员变量
（3）代码块
（4）成员内部类
（5）静态导入
3、静态方法：
（1）在本类中：可以直接被使用
（2）在其他类中：权限修饰符允许的前提下
A：建议，使用“类名.”进行调用
B：也可以，使用“对象名.”进行调用
（3）特殊
接口中的静态方法：只允许“接口名.静态方法”，不会继承到实现类中
父类中的静态方法：会继承到子类中，但是不允许子类进行重写

（4）在静态方法中不能
A：this
B：super
C：直接访问本类的其他非静态的成员（例如：实例变量、非静态方法、非静态内部类）

4、静态变量
（1）在本类中：可以直接被使用
（2）在其他类中：权限修饰符允许的前提下
A：建议，使用“类名.”进行调用
B：也可以，使用“对象名.”进行调用
（3）特殊
接口中的静态变量：必须是公共的，final，会继承到实现类中
父类中的静态变量：会继承到子类中

如果在实现类或子类中出现重名问题：
A：实现类中，出现与接口中的静态常量重名，使用“接口名.静态常量”
B：子类中，出现与父类中的静态变量重名，建议使用“父类名.静态变量”  或 也可以“super.静态变量”

5、静态代码块
（1）作用：为类的静态变量初始化
（2）调用的特点：
每一个的静态代码块只会执行一次；
在类初始化时执行，本质上它是被组装到<clinit>()中在类初始化时由类加载器调用执行

6、静态成员内部类
（1）在外部类中使用静态内部类，任意位置都可以用这个类
（2）在静态内部类中使用 外部类的成员：有限制，不能直接使用外部类的非静态成员
（3）在静态内部类中出现了与外部类的静态成员同名的问题，使用“外部类名.静态成员”
（4）在外部类中使用静态内部类的成员时：
A：使用静态内部类的私有的成员：可以
B：使用静态内部类的静态成员：“静态内部类名.静态成员”
C：使用静态内部类的非静态成员：需要先创建静态内部类的对象，然后使用“对象.”
（5）在外部类的外面（其他类）使用静态内部类的成员时：
A：使用静态内部类的私有的成员：不可以
B：使用静态内部类的静态成员：“外部类名.静态内部类名.静态成员”
C：使用静态内部类的非静态成员：需要先创建静态内部类的对象，然后使用“对象.”
    创建静态内部类的对象的方式： 外部类名.静态内部类名  对象名 = new 外部类名.静态内部类名（。。）；

7、静态导入
（1）什么情况下使用？
当我们使用另一个类的静态成员时，之前一般都是通过“类名.静态成员”方式使用，
例如：Math.PI，Math.sqrt(x)，Math.random()
     Arrays.sort(数组)，Arrays.sort(数组，Comparator比较器对象)
我们想要省略“类名.”，就可以使用静态导入

当我们大量的使用某个类的静态成员时，这样用可以简化代码，如果只用其中的一个或两个静态成员，直接“类名.”更简单。

（2）如何使用
import static 包.类名.静态成员名;
import static 包.类名.*;
 */
public class TestStatic {
    public static void main(String[] args) {
//        System.out.println(Math.PI);//如果没有静态导入，Math.是不能省略的
        System.out.println(PI);

//        Week monday = Week.MONDAY;//如果没有使用静态导入，Week.是不能省略的
        Week monday = MONDAY;
    }
}
